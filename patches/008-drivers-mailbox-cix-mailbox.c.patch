--- /tmp/linux-source-6.18-pristine/linux-source-6.18/drivers/mailbox/cix-mailbox.c	2026-01-11 08:26:20.000000000 -0600
+++ drivers/mailbox/cix-mailbox.c	2026-02-08 16:33:17.220980919 -0600
@@ -1,79 +1,80 @@
 // SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright 2025 Cix Technology Group Co., Ltd.
- */
+// Copyright 2024 Cix Technology Group Co., Ltd.
 
 #include <linux/device.h>
-#include <linux/err.h>
 #include <linux/io.h>
+#include <linux/err.h>
 #include <linux/interrupt.h>
-#include <linux/kernel.h>
 #include <linux/mailbox_controller.h>
 #include <linux/module.h>
+#include <linux/kernel.h>
 #include <linux/platform_device.h>
+#include <linux/acpi.h>
 
 #include "mailbox.h"
 
+/* Register define */
+#define REG_MSG(n)		(0x0 + 0x4*(n)) /* 0x0~0x7c */
+#define REG_DB_ACK		REG_MSG(CIX_MBOX_MSG_LEN) /* 0x80 */
+
 /*
- * The maximum transmission size is 32 words or 128 bytes.
+ * Some IO space is used by SCMI shared memory, if the DT reg address
+ * has bit 7 set (e.g., 0x6590080), we need to subtract this offset
+ * when accessing mailbox registers.
  */
-#define CIX_MBOX_MSG_WORDS	32	/* Max length = 32 words */
-#define CIX_MBOX_MSG_LEN_MASK	0x7fL	/* Max length = 128 bytes */
+#define CIX_SHMEM_OFFSET	0x80
+#define ERR_COMP		(REG_DB_ACK + 0x4) /* 0x84 */
+#define ERR_COMP_CLR		(REG_DB_ACK + 0x8) /* 0x88 */
+#define REG_F_INT(IDX)		(ERR_COMP_CLR + 0x4*(IDX+1)) /* 0x8c~0xa8 */
+#define FIFO_WR			(REG_F_INT(MBOX_FAST_IDX+1)) /* 0xac */
+#define FIFO_RD			(FIFO_WR + 0x4) /* 0xb0 */
+#define FIFO_STAS		(FIFO_WR + 0x8) /* 0xb4 */
+#define FIFO_WM			(FIFO_WR + 0xc) /* 0xb8 */
+#define INT_ENABLE		(FIFO_WR + 0x10) /* 0xbc */
+#define INT_ENABLE_SIDE_B	(FIFO_WR + 0x14) /* 0xc0 */
+#define INT_CLEAR		(FIFO_WR + 0x18) /* 0xc4 */
+#define INT_STATUS		(FIFO_WR + 0x1c) /* 0xc8 */
+#define FIFO_RST		(FIFO_WR + 0x20) /* 0xcc */
 
 /* [0~7] Fast channel
  * [8] doorbell base channel
  * [9]fifo base channel
  * [10] register base channel
  */
-#define CIX_MBOX_FAST_IDX	7
-#define CIX_MBOX_DB_IDX		8
-#define CIX_MBOX_FIFO_IDX	9
-#define CIX_MBOX_REG_IDX	10
-#define CIX_MBOX_CHANS	11
-
-/* Register define */
-#define CIX_REG_MSG(n)	(0x0 + 0x4*(n))			/* 0x0~0x7c */
-#define CIX_REG_DB_ACK	CIX_REG_MSG(CIX_MBOX_MSG_WORDS)	/* 0x80 */
-#define CIX_ERR_COMP	(CIX_REG_DB_ACK + 0x4)		/* 0x84 */
-#define CIX_ERR_COMP_CLR	(CIX_REG_DB_ACK + 0x8)		/* 0x88 */
-#define CIX_REG_F_INT(IDX)	(CIX_ERR_COMP_CLR + 0x4*(IDX+1))	/* 0x8c~0xa8 */
-#define CIX_FIFO_WR		(CIX_REG_F_INT(CIX_MBOX_FAST_IDX+1))	/* 0xac */
-#define CIX_FIFO_RD		(CIX_FIFO_WR + 0x4)			/* 0xb0 */
-#define CIX_FIFO_STAS	(CIX_FIFO_WR + 0x8)			/* 0xb4 */
-#define CIX_FIFO_WM		(CIX_FIFO_WR + 0xc)			/* 0xb8 */
-#define CIX_INT_ENABLE	(CIX_FIFO_WR + 0x10)		/* 0xbc */
-#define CIX_INT_ENABLE_SIDE_B	(CIX_FIFO_WR + 0x14)	/* 0xc0 */
-#define CIX_INT_CLEAR	(CIX_FIFO_WR + 0x18)		/* 0xc4 */
-#define CIX_INT_STATUS	(CIX_FIFO_WR + 0x1c)		/* 0xc8 */
-#define CIX_FIFO_RST	(CIX_FIFO_WR + 0x20)		/* 0xcc */
-
-#define CIX_MBOX_TX		0
-#define CIX_MBOX_RX		1
-
-#define CIX_DB_INT_BIT	BIT(0)
-#define CIX_DB_ACK_INT_BIT	BIT(1)
-
-#define CIX_FIFO_WM_DEFAULT		CIX_MBOX_MSG_WORDS
-#define CIX_FIFO_STAS_WMK		BIT(0)
-#define CIX_FIFO_STAS_FULL		BIT(1)
-#define CIX_FIFO_STAS_EMPTY		BIT(2)
-#define CIX_FIFO_STAS_UFLOW		BIT(3)
-#define CIX_FIFO_STAS_OFLOW		BIT(4)
-
-#define CIX_FIFO_RST_BIT		BIT(0)
-
-#define CIX_DB_INT			BIT(0)
-#define CIX_ACK_INT			BIT(1)
-#define CIX_FIFO_FULL_INT		BIT(2)
-#define CIX_FIFO_EMPTY_INT		BIT(3)
-#define CIX_FIFO_WM01_INT		BIT(4)
-#define CIX_FIFO_WM10_INT		BIT(5)
-#define CIX_FIFO_OFLOW_INT		BIT(6)
-#define CIX_FIFO_UFLOW_INT		BIT(7)
-#define CIX_FIFO_N_EMPTY_INT	BIT(8)
-#define CIX_FAST_CH_INT(IDX)	BIT((IDX)+9)
-
-#define CIX_SHMEM_OFFSET 0x80
+#define CIX_MBOX_CHANS		(11)
+#define CIX_MBOX_MSG_LEN	(32)
+#define MBOX_MSG_LEN_MASK	(0x7fL)
+
+#define MBOX_FAST_IDX		(7)
+#define MBOX_DB_IDX		(8)
+#define MBOX_FIFO_IDX		(9)
+#define MBOX_REG_IDX		(10)
+
+#define MBOX_TX			(0)
+#define MBOX_RX			(1)
+
+#define DB_INT_BIT		BIT(0)
+#define DB_ACK_INT_BIT		BIT(1)
+
+#define FIFO_WM_DEFAULT		CIX_MBOX_MSG_LEN
+#define FIFO_STAS_WMK		BIT(0)
+#define FIFO_STAS_FULL		BIT(1)
+#define FIFO_STAS_EMPTY		BIT(2)
+#define FIFO_STAS_UFLOW		BIT(3)
+#define FIFO_STAS_OFLOW		BIT(4)
+
+#define FIFO_RST_BIT		BIT(0)
+
+#define DB_INT			BIT(0)
+#define ACK_INT			BIT(1)
+#define FIFO_FULL_INT		BIT(2)
+#define FIFO_EMPTY_INT		BIT(3)
+#define FIFO_WM01_INT		BIT(4)
+#define FIFO_WM10_INT		BIT(5)
+#define FIFO_OFLOW_INT		BIT(6)
+#define FIFO_UFLOW_INT		BIT(7)
+#define FIFO_N_EMPTY_INT	BIT(8)
+#define FAST_CH_INT(IDX)	BIT((IDX)+9)
 
 enum cix_mbox_chan_type {
 	CIX_MBOX_TYPE_DB,
@@ -84,7 +85,7 @@
 
 struct cix_mbox_con_priv {
 	enum cix_mbox_chan_type type;
-	struct mbox_chan	*chan;
+	struct mbox_chan    *chan;
 	int index;
 };
 
@@ -92,21 +93,13 @@
 	struct device *dev;
 	int irq;
 	int dir;
-	void __iomem *base;	/* region for mailbox */
+	bool tx_irq_mode; /* flag of enabling tx's irq mode */
+	bool use_shmem; /* true if DT reg overlaps with SCMI shmem */
+	void __iomem *base; /* region for mailbox */
+	unsigned int chan_num;
 	struct cix_mbox_con_priv con_priv[CIX_MBOX_CHANS];
 	struct mbox_chan mbox_chans[CIX_MBOX_CHANS];
 	struct mbox_controller mbox;
-	bool use_shmem;
-};
-
-/*
- * The CIX mailbox supports four types of transfers:
- * CIX_MBOX_TYPE_DB, CIX_MBOX_TYPE_FAST, CIX_MBOX_TYPE_REG, and CIX_MBOX_TYPE_FIFO.
- * For the REG and FIFO types of transfers, the message format is as follows:
- */
-union cix_mbox_msg_reg_fifo {
-	u32 length;	/* unit is byte */
-	u32 buf[CIX_MBOX_MSG_WORDS]; /* buf[0] must be the byte length of this array */
 };
 
 static struct cix_mbox_priv *to_cix_mbox_priv(struct mbox_controller *mbox)
@@ -134,18 +127,15 @@
 {
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
 
-	return ((cix_mbox_read(priv, CIX_FIFO_STAS) & CIX_FIFO_STAS_EMPTY) ? true : false);
+	return ((cix_mbox_read(priv, FIFO_STAS) & FIFO_STAS_EMPTY) ? true : false);
 }
 
-/*
- *The transmission unit of the CIX mailbox is word.
- *The byte length should be converted into the word length.
- */
-static inline u32 mbox_get_msg_size(void *msg)
+static inline
+u32 mbox_get_msg_size(void *msg)
 {
 	u32 len;
 
-	len = ((u32 *)msg)[0] & CIX_MBOX_MSG_LEN_MASK;
+	len = ((u32 *)msg)[0] & MBOX_MSG_LEN_MASK;
 	return DIV_ROUND_UP(len, 4);
 }
 
@@ -154,7 +144,7 @@
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
 
 	/* trigger doorbell irq */
-	cix_mbox_write(priv, CIX_DB_INT_BIT, CIX_REG_DB_ACK);
+	cix_mbox_write(priv, DB_INT_BIT, REG_DB_ACK);
 
 	return 0;
 }
@@ -162,18 +152,19 @@
 static int cix_mbox_send_data_reg(struct mbox_chan *chan, void *data)
 {
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
-	union cix_mbox_msg_reg_fifo *msg = data;
-	u32 len, i;
+	int i;
+	u32 *arg = (u32 *)data;
+	u32 len;
 
 	if (!data)
 		return -EINVAL;
 
 	len = mbox_get_msg_size(data);
 	for (i = 0; i < len; i++)
-		cix_mbox_write(priv, msg->buf[i], CIX_REG_MSG(i));
+		cix_mbox_write(priv, arg[i], REG_MSG(i));
 
 	/* trigger doorbell irq */
-	cix_mbox_write(priv, CIX_DB_INT_BIT, CIX_REG_DB_ACK);
+	cix_mbox_write(priv, DB_INT_BIT, REG_DB_ACK);
 
 	return 0;
 }
@@ -181,21 +172,29 @@
 static int cix_mbox_send_data_fifo(struct mbox_chan *chan, void *data)
 {
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
-	union cix_mbox_msg_reg_fifo *msg = data;
-	u32 len, val, i;
+	int i;
+	u32 *arg = (u32 *)data;
+	u32 len, val_32, fifo_stas, int_status, int_en_b;
 
 	if (!data)
 		return -EINVAL;
 
 	len = mbox_get_msg_size(data);
-	cix_mbox_write(priv, len, CIX_FIFO_WM);
+	cix_mbox_write(priv, len, FIFO_WM);
 	for (i = 0; i < len; i++)
-		cix_mbox_write(priv, msg->buf[i], CIX_FIFO_WR);
+		cix_mbox_write(priv, arg[i], FIFO_WR);
 
 	/* Enable fifo empty interrupt */
-	val = cix_mbox_read(priv, CIX_INT_ENABLE);
-	val |= CIX_FIFO_EMPTY_INT;
-	cix_mbox_write(priv, val, CIX_INT_ENABLE);
+	val_32 = cix_mbox_read(priv, INT_ENABLE);
+	val_32 |= FIFO_EMPTY_INT;
+	cix_mbox_write(priv, val_32, INT_ENABLE);
+
+	/* Debug: check FIFO state after write */
+	fifo_stas = cix_mbox_read(priv, FIFO_STAS);
+	int_status = cix_mbox_read(priv, INT_STATUS);
+	int_en_b = cix_mbox_read(priv, INT_ENABLE_SIDE_B);
+	dev_info(priv->dev, "FIFO send: len=%u fifo_stas=0x%x int_status=0x%x int_en_b=0x%x\n",
+		 len, fifo_stas, int_status, int_en_b);
 
 	return 0;
 }
@@ -210,12 +209,12 @@
 	if (!data)
 		return -EINVAL;
 
-	if (index < 0 || index > CIX_MBOX_FAST_IDX) {
+	if (index < 0 || index > MBOX_FAST_IDX) {
 		dev_err(priv->dev, "Invalid Mbox index %d\n", index);
 		return -EINVAL;
 	}
 
-	cix_mbox_write(priv, arg[0], CIX_REG_F_INT(index));
+	cix_mbox_write(priv, arg[0], REG_F_INT(index));
 
 	return 0;
 }
@@ -225,7 +224,7 @@
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
 	struct cix_mbox_con_priv *cp = chan->con_priv;
 
-	if (priv->dir != CIX_MBOX_TX) {
+	if (priv->dir != MBOX_TX) {
 		dev_err(priv->dev, "Invalid Mbox dir %d\n", priv->dir);
 		return -EINVAL;
 	}
@@ -255,20 +254,20 @@
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
 	u32 int_status;
 
-	int_status = cix_mbox_read(priv, CIX_INT_STATUS);
+	int_status = cix_mbox_read(priv, INT_STATUS);
 
-	if (priv->dir == CIX_MBOX_RX) {
+	if (priv->dir == MBOX_RX) {
 		/* rx interrupt is triggered */
-		if (int_status & CIX_DB_INT) {
-			cix_mbox_write(priv, CIX_DB_INT, CIX_INT_CLEAR);
+		if (int_status & DB_INT) {
+			cix_mbox_write(priv, DB_INT, INT_CLEAR);
 			mbox_chan_received_data(chan, NULL);
 			/* trigger ack interrupt */
-			cix_mbox_write(priv, CIX_DB_ACK_INT_BIT, CIX_REG_DB_ACK);
+			cix_mbox_write(priv, DB_ACK_INT_BIT, REG_DB_ACK);
 		}
-	} else {
+	} else if (priv->dir == MBOX_TX) {
 		/* tx ack interrupt is triggered */
-		if (int_status & CIX_ACK_INT) {
-			cix_mbox_write(priv, CIX_ACK_INT, CIX_INT_CLEAR);
+		if (int_status & ACK_INT) {
+			cix_mbox_write(priv, ACK_INT, INT_CLEAR);
 			mbox_chan_received_data(chan, NULL);
 		}
 	}
@@ -278,28 +277,29 @@
 {
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
 	u32 int_status;
+	u32 data[CIX_MBOX_MSG_LEN];
+	int i;
+	u32 len;
 
-	int_status = cix_mbox_read(priv, CIX_INT_STATUS);
+	int_status = cix_mbox_read(priv, INT_STATUS);
 
-	if (priv->dir == CIX_MBOX_RX) {
+	if (priv->dir == MBOX_RX) {
 		/* rx interrupt is triggered */
-		if (int_status & CIX_DB_INT) {
-			u32 data[CIX_MBOX_MSG_WORDS], len, i;
-
-			cix_mbox_write(priv, CIX_DB_INT, CIX_INT_CLEAR);
-			data[0] = cix_mbox_read(priv, CIX_REG_MSG(0));
+		if (int_status & DB_INT) {
+			cix_mbox_write(priv, DB_INT, INT_CLEAR);
+			data[0] = cix_mbox_read(priv, REG_MSG(0));
 			len = mbox_get_msg_size(data);
-			for (i = 1; i < len; i++)
-				data[i] = cix_mbox_read(priv, CIX_REG_MSG(i));
+			for (i = 0; i < len; i++)
+				data[i] = cix_mbox_read(priv, REG_MSG(i));
 
 			/* trigger ack interrupt */
-			cix_mbox_write(priv, CIX_DB_ACK_INT_BIT, CIX_REG_DB_ACK);
+			cix_mbox_write(priv, DB_ACK_INT_BIT, REG_DB_ACK);
 			mbox_chan_received_data(chan, data);
 		}
-	} else {
+	} else if (priv->dir == MBOX_TX) {
 		/* tx ack interrupt is triggered */
-		if (int_status & CIX_ACK_INT) {
-			cix_mbox_write(priv, CIX_ACK_INT, CIX_INT_CLEAR);
+		if (int_status & ACK_INT) {
+			cix_mbox_write(priv, ACK_INT, INT_CLEAR);
 			mbox_chan_txdone(chan, 0);
 		}
 	}
@@ -308,46 +308,46 @@
 static void cix_mbox_isr_fifo(struct mbox_chan *chan)
 {
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
-	u32 int_status, status;
+	u32 data[CIX_MBOX_MSG_LEN];
+	int i = 0;
+	u32 int_status, status, val_32;
 
-	int_status = cix_mbox_read(priv, CIX_INT_STATUS);
+	int_status = cix_mbox_read(priv, INT_STATUS);
 
-	if (priv->dir == CIX_MBOX_RX) {
+	if (priv->dir == MBOX_RX) {
 		/* FIFO waterMark interrupt is generated */
-		if (int_status & (CIX_FIFO_FULL_INT | CIX_FIFO_WM01_INT)) {
-			u32 data[CIX_MBOX_MSG_WORDS] = { 0 }, i = 0;
-
-			cix_mbox_write(priv, (CIX_FIFO_FULL_INT | CIX_FIFO_WM01_INT),
-						CIX_INT_CLEAR);
+		if (int_status & (FIFO_FULL_INT | FIFO_WM01_INT)) {
+			cix_mbox_write(priv, (FIFO_FULL_INT | FIFO_WM01_INT), INT_CLEAR);
 			do {
-				data[i++] = cix_mbox_read(priv, CIX_FIFO_RD);
-			} while (!mbox_fifo_empty(chan) && i < CIX_MBOX_MSG_WORDS);
-
+				data[i++] = cix_mbox_read(priv, FIFO_RD);
+			} while (false == mbox_fifo_empty(chan));
 			mbox_chan_received_data(chan, data);
 		}
 		/* FIFO underflow is generated */
-		if (int_status & CIX_FIFO_UFLOW_INT) {
-			status = cix_mbox_read(priv, CIX_FIFO_STAS);
-			dev_err(priv->dev, "fifo underflow: int_stats %d\n", status);
-			cix_mbox_write(priv, CIX_FIFO_UFLOW_INT, CIX_INT_CLEAR);
+		if (int_status & FIFO_UFLOW_INT) {
+			status = cix_mbox_read(priv, FIFO_STAS);
+			dev_err(priv->dev,
+				"fifo underflow: int_stats %d\n",
+				status);
+			cix_mbox_write(priv, FIFO_UFLOW_INT, INT_CLEAR);
 		}
-	} else {
+	} else if (priv->dir == MBOX_TX) {
 		/* FIFO empty interrupt is generated */
-		if (int_status & CIX_FIFO_EMPTY_INT) {
-			u32 val;
-
-			cix_mbox_write(priv, CIX_FIFO_EMPTY_INT, CIX_INT_CLEAR);
+		if (int_status & FIFO_EMPTY_INT) {
+			cix_mbox_write(priv, FIFO_EMPTY_INT, INT_CLEAR);
 			/* Disable empty irq*/
-			val = cix_mbox_read(priv, CIX_INT_ENABLE);
-			val &= ~CIX_FIFO_EMPTY_INT;
-			cix_mbox_write(priv, val, CIX_INT_ENABLE);
+			val_32 = cix_mbox_read(priv, INT_ENABLE);
+			val_32 &= ~FIFO_EMPTY_INT;
+			cix_mbox_write(priv, val_32, INT_ENABLE);
 			mbox_chan_txdone(chan, 0);
 		}
 		/* FIFO overflow is generated */
-		if (int_status & CIX_FIFO_OFLOW_INT) {
-			status = cix_mbox_read(priv, CIX_FIFO_STAS);
-			dev_err(priv->dev, "fifo overlow: int_stats %d\n", status);
-			cix_mbox_write(priv, CIX_FIFO_OFLOW_INT, CIX_INT_CLEAR);
+		if (int_status & FIFO_OFLOW_INT) {
+			status = cix_mbox_read(priv, FIFO_STAS);
+			dev_err(priv->dev,
+				"fifo overlow: int_stats %d\n",
+				status);
+			cix_mbox_write(priv, FIFO_OFLOW_INT, INT_CLEAR);
 		}
 	}
 }
@@ -359,16 +359,19 @@
 	u32 int_status, data;
 
 	/* no irq will be trigger for TX dir mbox */
-	if (priv->dir != CIX_MBOX_RX)
+	if (priv->dir != MBOX_RX)
 		return;
 
-	int_status = cix_mbox_read(priv, CIX_INT_STATUS);
+	int_status = cix_mbox_read(priv, INT_STATUS);
 
-	if (int_status & CIX_FAST_CH_INT(cp->index)) {
-		cix_mbox_write(priv, CIX_FAST_CH_INT(cp->index), CIX_INT_CLEAR);
-		data = cix_mbox_read(priv, CIX_REG_F_INT(cp->index));
+	if (int_status & FAST_CH_INT(cp->index)) {
+		cix_mbox_write(priv,
+			       FAST_CH_INT(cp->index),
+			       INT_CLEAR);
+		data = cix_mbox_read(priv, REG_F_INT(cp->index));
 		mbox_chan_received_data(chan, &data);
 	}
+
 }
 
 static irqreturn_t cix_mbox_isr(int irq, void *arg)
@@ -402,15 +405,29 @@
 {
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
 	struct cix_mbox_con_priv *cp = chan->con_priv;
-	int index = cp->index, ret;
-	u32 val;
+	int ret;
+	int index = cp->index;
+	u32 val_32;
 
-	ret = request_irq(priv->irq, cix_mbox_isr, 0,
-			  dev_name(priv->dev), chan);
+	ret = request_irq(priv->irq,
+			  cix_mbox_isr,
+			  IRQF_NO_SUSPEND,
+			  dev_name(priv->dev),
+			  chan);
 	if (ret) {
-		dev_err(priv->dev, "Unable to acquire IRQ %d\n", priv->irq);
+		dev_err(priv->dev,
+			"Unable to acquire IRQ %d\n",
+			priv->irq);
 		return ret;
 	}
+	dev_info(priv->dev,
+		 "%s, base %px, irq %d, dir %d, type %d, index %d\n",
+		 __func__,
+		 priv->base,
+		 priv->irq,
+		 priv->dir,
+		 cp->type,
+		 cp->index);
 
 	switch (cp->type) {
 	case CIX_MBOX_TYPE_DB:
@@ -418,106 +435,102 @@
 		chan->txdone_method = TXDONE_BY_ACK;
 		fallthrough;
 	case CIX_MBOX_TYPE_REG:
-		if (priv->dir == CIX_MBOX_TX) {
+		if (priv->dir == MBOX_TX) {
 			/* Enable ACK interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE);
-			val |= CIX_ACK_INT;
-			cix_mbox_write(priv, val, CIX_INT_ENABLE);
-		} else {
+			val_32 = cix_mbox_read(priv, INT_ENABLE);
+			val_32 |= ACK_INT;
+			cix_mbox_write(priv, val_32, INT_ENABLE);
+		} else if (priv->dir == MBOX_RX) {
 			/* Enable Doorbell interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE_SIDE_B);
-			val |= CIX_DB_INT;
-			cix_mbox_write(priv, val, CIX_INT_ENABLE_SIDE_B);
+			val_32 = cix_mbox_read(priv, INT_ENABLE_SIDE_B);
+			val_32 |= DB_INT;
+			cix_mbox_write(priv, val_32, INT_ENABLE_SIDE_B);
 		}
 		break;
 	case CIX_MBOX_TYPE_FIFO:
 		/* reset fifo */
-		cix_mbox_write(priv, CIX_FIFO_RST_BIT, CIX_FIFO_RST);
+		cix_mbox_write(priv, FIFO_RST_BIT, FIFO_RST);
 		/* set default watermark */
-		cix_mbox_write(priv, CIX_FIFO_WM_DEFAULT, CIX_FIFO_WM);
-		if (priv->dir == CIX_MBOX_TX) {
+		cix_mbox_write(priv, FIFO_WM_DEFAULT, FIFO_WM);
+		if (priv->dir == MBOX_TX) {
 			/* Enable fifo overflow interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE);
-			val |= CIX_FIFO_OFLOW_INT;
-			cix_mbox_write(priv, val, CIX_INT_ENABLE);
-		} else {
+			val_32 = cix_mbox_read(priv, INT_ENABLE);
+			val_32 |= FIFO_OFLOW_INT;
+			cix_mbox_write(priv, val_32, INT_ENABLE);
+		} else if (priv->dir == MBOX_RX) {
 			/* Enable fifo full/underflow interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE_SIDE_B);
-			val |= CIX_FIFO_UFLOW_INT|CIX_FIFO_WM01_INT;
-			cix_mbox_write(priv, val, CIX_INT_ENABLE_SIDE_B);
+			val_32 = cix_mbox_read(priv, INT_ENABLE_SIDE_B);
+			val_32 |= FIFO_UFLOW_INT|FIFO_WM01_INT;
+			cix_mbox_write(priv, val_32, INT_ENABLE_SIDE_B);
 		}
 		break;
 	case CIX_MBOX_TYPE_FAST:
 		/* Only RX channel has intterupt */
-		if (priv->dir == CIX_MBOX_RX) {
-			if (index < 0 || index > CIX_MBOX_FAST_IDX) {
-				dev_err(priv->dev, "Invalid index %d\n", index);
-				ret = -EINVAL;
-				goto failed;
+		if (priv->dir == MBOX_RX) {
+			if (index < 0 || index > MBOX_FAST_IDX) {
+				dev_err(priv->dev,
+					"Invalid index %d\n", index);
+				return ret;
 			}
 			/* enable fast channel interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE_SIDE_B);
-			val |= CIX_FAST_CH_INT(index);
-			cix_mbox_write(priv, val, CIX_INT_ENABLE_SIDE_B);
+			val_32 = cix_mbox_read(priv, INT_ENABLE_SIDE_B);
+			val_32 |= FAST_CH_INT(index);
+			cix_mbox_write(priv, val_32, INT_ENABLE_SIDE_B);
 		}
 		break;
 	default:
 		dev_err(priv->dev, "Invalid channel type: %d\n", cp->type);
-		ret = -EINVAL;
-		goto failed;
+		return -EINVAL;
 	}
 	return 0;
-
-failed:
-	free_irq(priv->irq, chan);
-	return ret;
 }
 
 static void cix_mbox_shutdown(struct mbox_chan *chan)
 {
 	struct cix_mbox_priv *priv = to_cix_mbox_priv(chan->mbox);
 	struct cix_mbox_con_priv *cp = chan->con_priv;
+	u32 val_32;
 	int index = cp->index;
-	u32 val;
 
 	switch (cp->type) {
 	case CIX_MBOX_TYPE_DB:
 	case CIX_MBOX_TYPE_REG:
-		if (priv->dir == CIX_MBOX_TX) {
+		if (priv->dir == MBOX_TX) {
 			/* Disable ACK interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE);
-			val &= ~CIX_ACK_INT;
-			cix_mbox_write(priv, val, CIX_INT_ENABLE);
-		} else if (priv->dir == CIX_MBOX_RX) {
+			val_32 = cix_mbox_read(priv, INT_ENABLE);
+			val_32 &= ~ACK_INT;
+			cix_mbox_write(priv, val_32, INT_ENABLE);
+		} else if (priv->dir == MBOX_RX) {
 			/* Disable Doorbell interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE_SIDE_B);
-			val &= ~CIX_DB_INT;
-			cix_mbox_write(priv, val, CIX_INT_ENABLE_SIDE_B);
+			val_32 = cix_mbox_read(priv, INT_ENABLE_SIDE_B);
+			val_32 &= ~DB_INT;
+			cix_mbox_write(priv, val_32, INT_ENABLE_SIDE_B);
 		}
 		break;
 	case CIX_MBOX_TYPE_FIFO:
-		if (priv->dir == CIX_MBOX_TX) {
+		if (priv->dir == MBOX_TX) {
 			/* Disable empty/fifo overflow irq*/
-			val = cix_mbox_read(priv, CIX_INT_ENABLE);
-			val &= ~(CIX_FIFO_EMPTY_INT | CIX_FIFO_OFLOW_INT);
-			cix_mbox_write(priv, val, CIX_INT_ENABLE);
-		} else if (priv->dir == CIX_MBOX_RX) {
+			val_32 = cix_mbox_read(priv, INT_ENABLE);
+			val_32 &= ~(FIFO_EMPTY_INT | FIFO_OFLOW_INT);
+			cix_mbox_write(priv, val_32, INT_ENABLE);
+		} else if (priv->dir == MBOX_RX) {
 			/* Disable fifo WM01/underflow interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE_SIDE_B);
-			val &= ~(CIX_FIFO_UFLOW_INT | CIX_FIFO_WM01_INT);
-			cix_mbox_write(priv, val, CIX_INT_ENABLE_SIDE_B);
+			val_32 = cix_mbox_read(priv, INT_ENABLE_SIDE_B);
+			val_32 &= ~(FIFO_UFLOW_INT | FIFO_WM01_INT);
+			cix_mbox_write(priv, val_32, INT_ENABLE_SIDE_B);
 		}
 		break;
 	case CIX_MBOX_TYPE_FAST:
-		if (priv->dir == CIX_MBOX_RX) {
-			if (index < 0 || index > CIX_MBOX_FAST_IDX) {
-				dev_err(priv->dev, "Invalid index %d\n", index);
+		if (priv->dir == MBOX_RX) {
+			if (index < 0 || index > MBOX_FAST_IDX) {
+				dev_err(priv->dev,
+					"Invalid index %d\n", index);
 				break;
 			}
 			/* Disable fast channel interrupt */
-			val = cix_mbox_read(priv, CIX_INT_ENABLE_SIDE_B);
-			val &= ~CIX_FAST_CH_INT(index);
-			cix_mbox_write(priv, val, CIX_INT_ENABLE_SIDE_B);
+			val_32 = cix_mbox_read(priv, INT_ENABLE_SIDE_B);
+			val_32 &= ~FAST_CH_INT(index);
+			cix_mbox_write(priv, val_32, INT_ENABLE_SIDE_B);
 		}
 		break;
 
@@ -537,87 +550,118 @@
 
 static void cix_mbox_init(struct cix_mbox_priv *priv)
 {
-	struct cix_mbox_con_priv *cp;
 	int i;
+	struct cix_mbox_con_priv *cp;
 
 	for (i = 0; i < CIX_MBOX_CHANS; i++) {
 		cp = &priv->con_priv[i];
 		cp->index = i;
 		cp->chan = &priv->mbox_chans[i];
 		priv->mbox_chans[i].con_priv = cp;
-		if (cp->index <= CIX_MBOX_FAST_IDX)
+		if (cp->index <= MBOX_FAST_IDX)
 			cp->type = CIX_MBOX_TYPE_FAST;
-		if (cp->index == CIX_MBOX_DB_IDX)
+		if (cp->index == MBOX_DB_IDX)
 			cp->type = CIX_MBOX_TYPE_DB;
-		if (cp->index == CIX_MBOX_FIFO_IDX)
+		if (cp->index == MBOX_FIFO_IDX)
 			cp->type = CIX_MBOX_TYPE_FIFO;
-		if (cp->index == CIX_MBOX_REG_IDX)
+		if (cp->index == MBOX_REG_IDX)
 			cp->type = CIX_MBOX_TYPE_REG;
 	}
 }
 
+static struct mbox_chan *cix_mbox_xlate(struct mbox_controller *mbox,
+					const struct of_phandle_args *sp)
+{
+	int idx;
+
+	if (sp->args_count < 1)
+		return ERR_PTR(-EINVAL);
+	idx = sp->args[0];
+	if (idx >= mbox->num_chans)
+		return ERR_PTR(-EINVAL);
+	return &mbox->chans[idx];
+}
+
 static int cix_mbox_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct cix_mbox_priv *priv;
 	struct resource *res;
-	const char *dir_str;
 	int ret;
+	u32 dir;
 
+	pr_info("CIX-MBOX: probe called for %pOF\n", dev->of_node);
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
 	priv->dev = dev;
-	priv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
-	if (IS_ERR(priv->base))
-		return PTR_ERR(priv->base);
+
+	/* Get resource to check if shmem overlap applies */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
 
 	/*
-	 * The first 0x80 bytes of the register space of the cix mailbox controller
-	 * can be used as shared memory for clients. When this shared memory is in
-	 * use, the base address of the mailbox is offset by 0x80. Therefore, when
-	 * performing subsequent read/write operations, it is necessary to subtract
-	 * the offset CIX_SHMEM_OFFSET.
-	 *
-	 * When the base address of the mailbox is offset by 0x80, it indicates
-	 * that shmem is in use.
+	 * Detect if the DT reg address has the SHMEM offset bit set.
+	 * If so, the first 0x80 bytes are used by SCMI shared memory,
+	 * and we need to adjust register offsets accordingly.
 	 */
 	priv->use_shmem = !!(res->start & CIX_SHMEM_OFFSET);
 
+	/* Use devm_ioremap instead of devm_ioremap_resource to avoid
+	 * resource conflicts with SCMI shmem devices (CIXHA004/CIXHA005)
+	 * which claim sub-regions of the mailbox MMIO space.
+	 */
+	priv->base = devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+
 	priv->irq = platform_get_irq(pdev, 0);
 	if (priv->irq < 0)
 		return priv->irq;
 
-	if (device_property_read_string(dev, "cix,mbox-dir", &dir_str)) {
+	if (device_property_read_u32(dev, "cix,mbox_dir", &dir)) {
 		dev_err(priv->dev, "cix,mbox_dir property not found\n");
 		return -EINVAL;
 	}
 
-	if (!strcmp(dir_str, "tx"))
-		priv->dir = 0;
-	else if (!strcmp(dir_str, "rx"))
-		priv->dir = 1;
-	else {
-		dev_err(priv->dev, "cix,mbox_dir=%s is not expected\n", dir_str);
+	if ((dir != MBOX_TX)
+	    && (dir != MBOX_RX)) {
+		dev_err(priv->dev, "Dir value is not expected! dir %d\n", dir);
 		return -EINVAL;
 	}
 
 	cix_mbox_init(priv);
 
+	priv->dir = (int)dir;
 	priv->mbox.dev = dev;
 	priv->mbox.ops = &cix_mbox_chan_ops;
 	priv->mbox.chans = priv->mbox_chans;
 	priv->mbox.txdone_irq = true;
 	priv->mbox.num_chans = CIX_MBOX_CHANS;
-	priv->mbox.of_xlate = NULL;
+	priv->mbox.of_xlate = cix_mbox_xlate;
+	dev_info(priv->dev,
+		 "%s, base %px, irq %d, dir %d, use_shmem %d\n",
+		 __func__,
+		 priv->base,
+		 priv->irq,
+		 priv->dir,
+		 priv->use_shmem);
 
 	platform_set_drvdata(pdev, priv);
 	ret = devm_mbox_controller_register(dev, &priv->mbox);
 	if (ret)
-		dev_err(dev, "Failed to register mailbox %d\n", ret);
+		return ret;
 
-	return ret;
+	return 0;
+}
+
+static void cix_mbox_remove(struct platform_device *pdev)
+{
+	struct cix_mbox_priv *priv = platform_get_drvdata(pdev);
+
+	dev_info(priv->dev, "cix mbox removed\n");
 }
 
 static const struct of_device_id cix_mbox_dt_ids[] = {
@@ -626,20 +670,32 @@
 };
 MODULE_DEVICE_TABLE(of, cix_mbox_dt_ids);
 
+static const struct acpi_device_id cix_mbox_acpi_match[] = {
+	{ "CIXHA001", 0 }, /* sky1 mailbox */
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, cix_mbox_acpi_match);
+
 static struct platform_driver cix_mbox_driver = {
 	.probe = cix_mbox_probe,
+	.remove = cix_mbox_remove,
 	.driver = {
 		.name = "cix_mbox",
 		.of_match_table = cix_mbox_dt_ids,
+		.acpi_match_table = ACPI_PTR(cix_mbox_acpi_match),
 	},
 };
 
 static int __init cix_mailbox_init(void)
 {
-	return platform_driver_register(&cix_mbox_driver);
+	int ret;
+	pr_emerg("CIX-MBOX: driver init (subsys_initcall)\n");
+	ret = platform_driver_register(&cix_mbox_driver);
+	pr_emerg("CIX-MBOX: driver registered, ret=%d\n", ret);
+	return ret;
 }
-arch_initcall(cix_mailbox_init);
+subsys_initcall(cix_mailbox_init);
 
-MODULE_AUTHOR("Cix Technology Group Co., Ltd.");
+MODULE_AUTHOR("Lihua Liu <Lihua.Liu@cixcomputing.com>");
 MODULE_DESCRIPTION("CIX mailbox driver");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
